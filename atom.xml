<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>👩🏻‍💻</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-15T03:17:06.389Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>🤡Ling</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>挖掘 Echarts 的秘密</title>
    <link href="http://yoursite.com/2019/08/14/echarts/"/>
    <id>http://yoursite.com/2019/08/14/echarts/</id>
    <published>2019-08-14T08:22:54.000Z</published>
    <updated>2019-08-15T03:17:06.389Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;记录较少的人才用到的 Echarts 功能 (以下均以官网的折线图堆叠实例为参考例子分析)</p><a id="more"></a><h3 id="自定义图表鼠标悬浮显示的内容"><a href="#自定义图表鼠标悬浮显示的内容" class="headerlink" title="自定义图表鼠标悬浮显示的内容"></a>自定义图表鼠标悬浮显示的内容</h3><p>&emsp;&emsp;正常情况下，echarts 的显示内容为：<strong>横坐标值 + 所选中的 legend 的颜色 + 所选中的 legend 名称 + 纵坐标值</strong>（如图 1-1）</p><div style="width:400px; margin: 0 auto; text-align: center"><p>  <img src="/photos/echarts-1.png" alt="基本布局"><br>  图1-1 基础的 Echarts 鼠标悬浮显示</p></div>&emsp;&emsp;有些时候我们希望这个悬浮框能不止是显示这些信息，还希望展示自己定义的或者动态的数据，Echarts 也做到了。<br><br><p><strong>需要知道的</strong>（tooltip 的 formatter 具体详细就去<a href="https://echarts.baidu.com/option.html#tooltip.formatter" target="_blank" rel="noopener">官方文档</a>）</p><ul><li><p>tooltip 里的 formatter 函数的参数 params，当鼠标悬浮到折线上显示的参数详情如下：</p><div style="width:600px"><p><img src="/photos/echarts-2.png" alt="基本布局"></p></div></li></ul><p><strong>自定义详情</strong></p><ol><li><p>series 中的 data 可以传入对象（对象的最好不要用 Echarts 的变量名），对象的 value 就是平时我们传入 data 数组内的值，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123; <span class="attr">brand</span>: <span class="string">'百度'</span>, <span class="attr">value</span>: <span class="number">820</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">brand</span>: <span class="string">'谷歌'</span>, <span class="attr">value</span>: <span class="number">932</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">brand</span>: <span class="string">'火狐'</span>, <span class="attr">value</span>: <span class="number">901</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">brand</span>: <span class="string">'IE'</span>, <span class="attr">value</span>: <span class="number">934</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">brand</span>: <span class="string">'Safari'</span>, <span class="attr">value</span>: <span class="number">1290</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">brand</span>: <span class="string">'360'</span>, <span class="attr">value</span>: <span class="number">1330</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">brand</span>: <span class="string">'QQ浏览器'</span>, <span class="attr">value</span>: <span class="number">1320</span> &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>在 tooltip 内添加 formatter 函数，并打印参数，可以观察到如下图：</p><div style="width:600px; text-align: center"><p><img src="/photos/echarts-3.png" alt="基本布局"></p></div></li><li><p>所以就可以自由拼接想要的鼠标悬浮框内容啦</p><div style="width:500px;margin: 0 auto"><p><img src="/photos/echarts-4.png" alt="基本布局"></p></div></li></ol><hr><h3 id="自定义-legend-悬浮显示的内容"><a href="#自定义-legend-悬浮显示的内容" class="headerlink" title="自定义 legend 悬浮显示的内容"></a>自定义 legend 悬浮显示的内容</h3><p>&emsp;&emsp;普通情况下，echarts 的上面的 legend 在鼠标放上去的时候会触发下方图表的对应曲线的高亮显示，并不会触发其他的。有时候会希望 legend 在鼠标放上去的时候能显示这个 legend 的详细说明，于是又去研究 Echarts 的 legend 了。</p><ol><li><p>同样的，在 legend 内部添加 formatter 函数，并打印出参数内容，如下图: </p><div style="width:500px;"><p><img src="/photos/echarts-5.png" alt="基本布局"></p></div><div style="width:300px;"><p><img src="/photos/echarts-6.png" alt="基本布局"></p></div></li><li><p>得知打印出的东西之后，将 legend 内的 tooltip 的show 值改为 true，然后就可以开始对 legend 的 data 进行操作了。（⚠️注意：legend 内的数据必须和 series 的 data 的 name 一致）修改成如下图的亚子:</p><div style="width:500px;"><p><img src="/photos/echarts-7.png" alt="基本布局"></p></div></li><li><p>修改后的 Echarts 变成了这样：</p><div style="width:500px;margin: 0 auto"><p><img src="/photos/echarts-8.png" alt="基本布局"></p></div></li><li><p>此时需要对 formatter 内部的 return的值进行处理， 同时 tooltip 内的 formatter 返回的 name 也需要处理以下。处理有两种方法：</p><ul><li><p>直接对字符串进行切割处理：调用字符串的 <strong>silce</strong> 方法；</p></li><li><p>调用 echarts 封装好的方法（好处是可以自定义字体）：<strong>echarts.format.truncateText(name, 60, ‘14px Microsoft Yahei’, ‘’)</strong><br>两种方法用法如下图：</p><div style="width:500px;"><p><img src="/photos/echarts-9.png" alt="基本布局"></p></div></li></ul></li><li><p>效果：可以看到 legend 的 hover 显示可以出现了，并且也不影响下方折线的文字显示。</p><div style="width:500px;margin-left: 30px"><p> <img src="/photos/echarts-10.gif" alt="基本布局"></p></div></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;记录较少的人才用到的 Echarts 功能 (以下均以官网的折线图堆叠实例为参考例子分析)&lt;/p&gt;
    
    </summary>
    
    
      <category term="Echarts" scheme="http://yoursite.com/tags/Echarts/"/>
    
  </entry>
  
  <entry>
    <title>ReactNative踩坑记录（一）环境配置问题</title>
    <link href="http://yoursite.com/2018/06/01/ReactNative-1/"/>
    <id>http://yoursite.com/2018/06/01/ReactNative-1/</id>
    <published>2018-06-01T02:33:40.000Z</published>
    <updated>2019-08-13T07:50:27.616Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;学了一点点React皮毛的我决定尝试下一下React Native :) </p><a id="more"></a><p>&emsp;&emsp;明明很简单的配置，到我这里却各种出错，一路踩坑过来的我总算把ios环境配置好了。基础配置可以跟着<a href="https://reactnative.cn/docs/0.36/getting-started.html" target="_blank" rel="noopener">官网配置环境</a>来，上面写的很详细了。 我就分享一下我遇到的问题和解决方法：</p><p><font color="black" size="5"><strong>React Native run-ios 的问题</strong></font></p><ol><li><font color="red"><strong>ReactNative 创建项目的时候没有权限</strong></font><br>&emsp;&emsp;<strong>错误信息:</strong> <font color="red">EACCES: permission denied, open ‘/Users/apple/.babel.json’</font><br>&emsp;&emsp;这种属于权限Mac的权限问题解决方法：<br>&emsp;&emsp;&emsp;&emsp;<strong>sudo chmod -R 777 /Users/apple/.babel.json</strong><br>&emsp;&emsp;然后删除项目重新init新的项目：<br>&emsp;&emsp;&emsp;&emsp;<strong>react-native init awesome-project</strong></li><li><font color="red"><strong>安装watchman的问题</strong></font><br>&emsp;&emsp;&emsp;个人建议用最新的Xcode版本，因为我不想更新Xcode，觉得太大了，太占内存（贫穷的我用的是Air）就没有更新，结果watchman安装还报错，所以建议先更新Xcode吧，省事。</li><li><font color="red"><strong>ReactNative run-ios 报错</strong></font><br>&emsp;&emsp;<strong>错误信息:</strong> <font color="red">Permission denied. Make sure watchman is running for this project.</font><br>&emsp;&emsp;这个是因为init命令默认会创建最新的版本，而目前最新的0.45及以上版本需要下载boost等几个第三方库编译。这些库在国内即便翻墙也很难下载成功，导致无法运行iOS项目。我没有对新版本的需求，所以我暂时创建的是0.44.3的版本，把之前的项目删除，重新创建项目：<br>&emsp;&emsp;&emsp;&emsp;<strong>react-native init awesome-project –version 0.44.3</strong></li><li>等我安装了 AndroidStudio 再更新 run-andriod 的问题吧 :)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;学了一点点React皮毛的我决定尝试下一下React Native :) &lt;/p&gt;
    
    </summary>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
      <category term="React Native" scheme="http://yoursite.com/tags/React-Native/"/>
    
  </entry>
  
  <entry>
    <title>JS对数组去重的几种方法</title>
    <link href="http://yoursite.com/2018/04/22/JS%E5%AF%B9%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/04/22/JS对数组去重的几种方法/</id>
    <published>2018-04-22T14:11:49.000Z</published>
    <updated>2019-08-13T07:51:42.692Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;面试经常问的一道题<br>&emsp;<strong>JS对数组去重的几种方法 (前面六种方法是普通数组，最后一种是对象数组)</strong></p><a id="more"></a><p><font color="black" size="4"><strong>方法一：</strong></font> 最原始的方法，定义一个新数组，并存放原数组的第一个元素，然后将元素组一一和新数组的元素对比，若不同则存放在新数组中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ <span class="number">1</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'1'</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniqueArr</span>(<span class="params">oldArr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 新的数组 用来存放去重后的值</span></span><br><span class="line">  <span class="keyword">var</span> newArr = [];  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; oldArr.length ;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span> ; j &lt; newArr.length; j++) </span><br><span class="line">      <span class="comment">// 如果两数相等 则跳出第二个循环</span></span><br><span class="line">      <span class="keyword">if</span> (oldArr[i] === newArr[j]) <span class="keyword">break</span>; </span><br><span class="line">    <span class="comment">// 一轮循环结束还没跳出循环 则表示此数未再新数组里出现 则加入新数组 </span></span><br><span class="line">    <span class="keyword">if</span> (j == newArr.length)  newArr.push(oldArr[i]);   </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(uniqueArr(arr));  <span class="comment">// [ 1, '1' ]</span></span><br></pre></td></tr></table></figure><p><font color="black" size="4"><strong>方法二：</strong></font> 先将数组排序，再相邻的进行比较，不同的存入新数组。（这个方法有缺陷，因为sort是按照字符编码的顺序进行排序，所以要先将数组的元素转换为字符串，来进行比较，下面的数组的这种情况就不能完美的去重。 <strong>个人认为sort方法是通过交换实现的排序，在数据量比较小的时候用的是冒泡排序，数据量比较大时用的是快速排序</strong>）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ <span class="number">1</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniqueArr</span>(<span class="params">oldArr</span>) </span>&#123;</span><br><span class="line">  oldArr = oldArr.sort(); </span><br><span class="line">  <span class="keyword">var</span> newArr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; oldArr.length ; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(oldArr[i] !== newArr[newArr.length<span class="number">-1</span>])</span><br><span class="line">      newArr.push(oldArr[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(uniqueArr(arr));  <span class="comment">// [ 1, '1', 1 ]</span></span><br></pre></td></tr></table></figure><p><font color="black" size="4"><strong>方法三：</strong></font> 利用数组的indexOf下标属性来简化循环 (includes 也是一样的)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ <span class="number">1</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniqueArr</span>(<span class="params">oldArr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newArr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span> ; i &lt; oldArr.length ; i++) </span><br><span class="line">    <span class="comment">//  利用indexof 判断某个值是否在新的数组里面</span></span><br><span class="line">    <span class="keyword">if</span>(newArr.indexOf(oldArr[i]) === <span class="number">-1</span>) </span><br><span class="line">      newArr.push(oldArr[i]);</span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(uniqueArr(arr));   <span class="comment">// [ 1, '1' ]</span></span><br></pre></td></tr></table></figure><p><font color="black" size="4"><strong>方法四：</strong></font> 利用ES6的 filter 方法 加上indexOf 返回第一个item出现的位置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ <span class="number">1</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="number">1</span>, <span class="string">'2'</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniqueArr</span>(<span class="params">oldArr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newArr = oldArr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, oldArr</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// indexOf 返回第一个item出现的位置 </span></span><br><span class="line">    <span class="keyword">return</span> oldArr.indexOf(item) === index;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(uniqueArr(arr));  <span class="comment">// [ 1, '1', '2' ]</span></span><br></pre></td></tr></table></figure><p><font color="black" size="4"><strong>方法五：</strong></font> 利用对象属性存在的特性，如果没有该属性则存入新数组 (这里的 1 和 ‘1’ 在用obj[]添加属性时，会被自动换成 1 然后加入进obj)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ <span class="number">1</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="number">1</span>, <span class="string">'2'</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniqueArr</span>(<span class="params">oldArr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> newArr = [];</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;oldArr.length; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>( !obj[oldArr[i]] )&#123;</span><br><span class="line">      <span class="comment">// 属性不存在 则加入新数组 并将该属性变为 1</span></span><br><span class="line">      obj[oldArr[i]] = <span class="number">1</span>;</span><br><span class="line">      newArr.push(oldArr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(uniqueArr(arr));   <span class="comment">// [ 1, '2' ]</span></span><br></pre></td></tr></table></figure><p><font color="black" size="4"><strong>方法六：</strong></font>利用ES6的 set 对象自动去重</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ <span class="number">1</span>, <span class="number">1</span>, <span class="string">'1'</span>, <span class="string">'1'</span>, <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniqueArr</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(arr));  <span class="comment">// 利用Array.from 将Set结构转换为数组</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(uniqueArr(arr));   <span class="comment">// [ 1, '1' ]</span></span><br></pre></td></tr></table></figure><p><font color="black" size="4"><strong>Object键值对去重</strong></font></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [&#123;<span class="attr">value</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">value</span>: <span class="number">1</span>&#125;, &#123;<span class="attr">value</span>: <span class="number">2</span>&#125;];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uniqueArr</span>(<span class="params">oldArr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> oldArr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, oldArr</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 判断 obj 对象是否存在item这个属性  存在的话返回fasle 不存在的话 向Obj中添加该属性</span></span><br><span class="line">    <span class="keyword">return</span> obj.hasOwnProperty(<span class="keyword">typeof</span> item + <span class="built_in">JSON</span>.stringify(item)) ? <span class="literal">false</span> : (obj[<span class="keyword">typeof</span> item + <span class="built_in">JSON</span>.stringify(item)] = <span class="literal">true</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(uniqueArr(arr));   <span class="comment">// [&#123;value: 1&#125;, &#123;value: 2&#125;]</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;面试经常问的一道题&lt;br&gt;&amp;emsp;&lt;strong&gt;JS对数组去重的几种方法 (前面六种方法是普通数组，最后一种是对象数组)&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="http://yoursite.com/2018/04/19/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/04/19/排序算法/</id>
    <published>2018-04-19T15:14:27.000Z</published>
    <updated>2019-08-13T08:03:34.683Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="交换类排序"><a href="#交换类排序" class="headerlink" title="交换类排序"></a>交换类排序</h3><p>&emsp;&emsp;交换排序的基本方法是：通过一系列的交换元素过程，把原本逆序的元素交换为正确的顺序的排序方法。常见的冒泡排序和快速排序就属于交换类排序。</p><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>&emsp;&emsp;<strong>冒泡排序</strong>（英语：<strong>Bubble Sort</strong>）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来（这里的顺序错误指的是两个元素没有按照你想排的顺序）。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。</p><p>  &emsp;&emsp;&emsp;<strong>优点：</strong>  简单稳定<br>  &emsp;&emsp;&emsp;<strong>缺点：</strong>  效率不高，慢（一次只能移动相邻两个数据）<br>  &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>最坏时间复杂度：</strong> <em>O(𝒏²)</em><br>  &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>最优时间复杂度：</strong> <em>O(𝒏)</em><br>  &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>平均时间复杂度：</strong> <em>O(𝒏²)</em><br>  &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>空间复杂度：</strong> 总共 <em>O(𝒏)</em></p><p>  &emsp;&emsp;冒泡排序算法的运作如下：<br>  &emsp;&emsp;&emsp;&emsp;1. 从第一个元素开始，比较相邻的元素。如果第一个比第二个大，就交换他们两个。<br>  &emsp;&emsp;&emsp;&emsp;2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数，将数列长度减一，再针对所有的元素重复以上的步骤 。<br>  &emsp;&emsp;&emsp;&emsp;3. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JS代码实现：</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.bubble_sort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;    <span class="comment">// 为Array添加一个方法</span></span><br><span class="line">  <span class="keyword">var</span> temp;  <span class="comment">// 交换两个数暂时存放用</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length - <span class="number">1</span>; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; <span class="keyword">this</span>.length - <span class="number">1</span> - i; j++)</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>[j] &gt; <span class="keyword">this</span>[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        temp = <span class="keyword">this</span>[j];</span><br><span class="line">        <span class="keyword">this</span>[j] = <span class="keyword">this</span>[j + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">this</span>[j + <span class="number">1</span>] = temp;  <span class="comment">// 顺序不同的 交换两个数的位置</span></span><br><span class="line">      &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>&emsp;&emsp;<strong>快速排序</strong>（英语：<em>Quicksort</em>），又称划分交换排序（partition-exchange sort），简称快排，是冒泡排序的改进版。</p><p>  &emsp;&emsp;&emsp;<strong>优点：</strong> 极快，快速排序是目前已知的最快的排序方法，数据移动少<br>  &emsp;&emsp;&emsp;<strong>缺点：</strong> 不稳定<br>  &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>最坏时间复杂度：</strong> <em>O(𝒏²)</em><br>  &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>最优时间复杂度：</strong> <em>O(𝒏log𝒏)</em><br>  &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>平均时间复杂度：</strong> <em>O(𝒏log𝒏)</em><br>  &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>空间复杂度：</strong> 实现的方式不同空间复杂度也不同</p><p>  &emsp;&emsp;快速排序算法的运作如下：<br>  &emsp;&emsp;&emsp;&emsp;1. 从数列中挑出一个元素，称为”基准”（pivot）。<br>  &emsp;&emsp;&emsp;&emsp;2. 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作 。<br>  &emsp;&emsp;&emsp;&emsp;3. 针对所有的元素重复以上的步骤，除了最后一个 。<br>  &emsp;&emsp;&emsp;&emsp;4. 递归地（recursively）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p><!-- 图片居中的方法 --><div align="center"><p>  <img src="/photos/Sorting_quicksort_anim.gif" alt="基本布局"><br>  图1.2-1 快速排序的过程</p></div>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JS代码实现：</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.quick_sort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> len = <span class="keyword">this</span>.length;</span><br><span class="line">  <span class="keyword">if</span> (len &lt;= <span class="number">1</span>)   <span class="comment">// 判断数组此时的长度 小于等于1时 返回最后一个数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.slice(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">var</span> left = [];</span><br><span class="line">  <span class="keyword">var</span> right = [];</span><br><span class="line">  <span class="keyword">var</span> mid = [<span class="keyword">this</span>[<span class="number">0</span>]];</span><br><span class="line">  <span class="comment">// 分别将小于mid的放入左边和右边</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>[i] &lt; mid[<span class="number">0</span>])</span><br><span class="line">      left.push(<span class="keyword">this</span>[i]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      right.push(<span class="keyword">this</span>[i]);</span><br><span class="line">  <span class="comment">// 利用递归 不断交换</span></span><br><span class="line">  <span class="keyword">return</span> left.quick_sort().concat(mid.concat(right.quick_sort()));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>&emsp;&emsp;<strong>选择排序</strong>（<em>Selection sort</em>）是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。<br>选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对 <strong>𝒏</strong> 个元素的表进行排序总共进行至多 <strong>𝒏 − 1</strong> 次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p><p>  &emsp;&emsp;&emsp;<strong>优点：</strong> 移动数据的次数已知 （n-1）次<br>  &emsp;&emsp;&emsp;<strong>缺点：</strong> 比较次数多<br>  &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>最坏时间复杂度：</strong> <em>O(𝒏²)</em><br>  &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>最优时间复杂度：</strong> <em>O(𝒏²)</em><br>  &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>平均时间复杂度：</strong> <em>O(𝒏²)</em><br>  &emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>空间复杂度：</strong> <em>O(𝒏)</em></p><div align="center"><p>  <img src="/photos/Selection-Sort-Animation.gif" alt="基本布局"><br>  图2-1 选择排序的过程</p></div>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JS代码实现</span></span><br><span class="line">  <span class="built_in">Array</span>.prototype.selection_sort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> min;</span><br><span class="line">    <span class="keyword">var</span> temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      min = i;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; <span class="keyword">this</span>.length; j++)</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>[min] &gt; <span class="keyword">this</span>[j])</span><br><span class="line">          min = j;</span><br><span class="line">      temp = <span class="keyword">this</span>[min];</span><br><span class="line">      <span class="keyword">this</span>[min] = <span class="keyword">this</span>[i];</span><br><span class="line">      <span class="keyword">this</span>[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>&emsp;&emsp;<strong>插入排序</strong>（英语：<em>Insertion Sort</em>）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用 in-place 排序（即只需用到 <em>O(1)</em>的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><p>&emsp;&emsp;&emsp;<strong>优点：</strong> 稳定，快<br>&emsp;&emsp;&emsp;<strong>缺点：</strong> 比较次数不一定，比较次数越少，插入点后的数据移动越多，特别是当数据总量庞大的时候 。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>最坏时间复杂度：</strong> <em>O(𝒏²)</em><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>最优时间复杂度：</strong> <em>O(𝒏)</em><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>平均时间复杂度：</strong> <em>O(𝒏²)</em><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>空间复杂度：</strong> 总共 <em>O(𝒏)</em> 需要辅助空间 <em>O(1)</em></p><p>&emsp;&emsp;插入排序算法的运作如下：<br>&emsp;&emsp;&emsp;&emsp;1. 从第一个元素开始，该元素可以认为已经被排序<br>&emsp;&emsp;&emsp;&emsp;2. 取出下一个元素，在已经排序的元素序列中从后向前扫描<br>&emsp;&emsp;&emsp;&emsp;3. 如果该元素（已排序）大于新元素，将该元素移到下一位置<br>&emsp;&emsp;&emsp;&emsp;4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置<br>&emsp;&emsp;&emsp;&emsp;5. 将新元素插入到该位置后<br>&emsp;&emsp;&emsp;&emsp;6. 重复步骤2~5</p><!-- 图片居中的方法 --><div align="center"><p>  <img src="/photos/Insertion-sort-example-300px.gif" alt="基本布局"><br>  图3-1 插入排序的过程</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JS代码实现</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.insertion_sort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>;i &lt; <span class="keyword">this</span>.length; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; i ; j++)</span><br><span class="line">     <span class="keyword">if</span>(<span class="keyword">this</span>[j] &gt; <span class="keyword">this</span>[i]) &#123;</span><br><span class="line">        <span class="keyword">this</span>.splice(j,<span class="number">0</span>,<span class="keyword">this</span>[i]);  <span class="comment">// 往前插入</span></span><br><span class="line">        <span class="keyword">this</span>.splice(i+<span class="number">1</span>,<span class="number">1</span>); <span class="comment">// 删除之前的那个数字</span></span><br><span class="line">      &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>&emsp;&emsp;<strong>归并排序</strong>（英语：<em>Merge sort</em>）是创建在归并操作上的一种有效的排序算法，是采用<strong>分治法</strong>的一个非常典型的应用，且各层分治递归可以同时进行。</p><p>&emsp;&emsp;&emsp;<strong>优点：</strong> 效率高，稳定<br>&emsp;&emsp;&emsp;<strong>缺点：</strong> 空间复杂度略高<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>最坏时间复杂度：</strong> <em>O(𝒏log𝒏)</em><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>最优时间复杂度：</strong> <em>O(𝒏)</em><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>平均时间复杂度：</strong> <em>O(𝒏log𝒏)</em><br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;<strong>空间复杂度：</strong> 总共 <em>O(𝒏)</em> </p><p>&emsp;&emsp;归并排序算法的运作如下：<br>&emsp;&emsp;<font color="black" size="3"><strong>递归法:</strong></font><br>&emsp;&emsp;&emsp;&emsp;1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列<br>&emsp;&emsp;&emsp;&emsp;2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置<br>&emsp;&emsp;&emsp;&emsp;3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置<br>&emsp;&emsp;&emsp;&emsp;4. 重复步骤3直到某一指针到达序列尾<br>&emsp;&emsp;&emsp;&emsp;5. 将另一序列剩下的所有元素直接复制到合并序列尾</p><p>&emsp;&emsp;<font color="black" size="3"><strong>迭代法:</strong></font><br>&emsp;&emsp;原理如下（假设序列共有 <em>n</em> 个元素）：<br>&emsp;&emsp;&emsp;&emsp;1. 将序列每相邻两个数字进行归并操作，形成 <em>ceil(n/2)</em> 个序列，排序后每个序列包含两/一个元素<br>&emsp;&emsp;&emsp;&emsp;2. 若此时序列数不是1个则将上述序列再次归并，形成 <em>ceil(n/4)</em> 个序列，每个序列包含四/三个元素<br>&emsp;&emsp;&emsp;&emsp;3. 重复步骤2，直到所有元素排序完毕，即序列数为1</p><!-- 图片居中的方法 --><div align="center"><p>  <img src="/photos/Merge-sort.gif" alt="基本布局"><br>  图4-1 归并排序的过程</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JS代码实现</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.merge_sort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> merge = <span class="function"><span class="keyword">function</span>(<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> final = [];</span><br><span class="line">    <span class="keyword">while</span> (left.length &amp;&amp; right.length)</span><br><span class="line">      final.push(left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>] ? left.shift() : right.shift());</span><br><span class="line">    <span class="keyword">return</span> final.concat(left.concat(right));</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> len = <span class="keyword">this</span>.length;</span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">var</span> mid = len / <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> merge(<span class="keyword">this</span>.slice(<span class="number">0</span>, <span class="built_in">parseInt</span>(mid)).merge_sort(), <span class="keyword">this</span>.slice(<span class="built_in">parseInt</span>(mid)).merge_sort());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;交换类排序&quot;&gt;&lt;a href=&quot;#交换类排序&quot; class=&quot;headerlink&quot; title=&quot;交换类排序&quot;&gt;&lt;/a&gt;交换类排序&lt;/h3&gt;&lt;p&gt;&amp;emsp;&amp;emsp;交换排序的基本方法是：通过一系列的交换元素过程，把原本逆
      
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>完整的URL请求页面过程</title>
    <link href="http://yoursite.com/2018/04/18/%E5%AE%8C%E6%95%B4%E7%9A%84URL%E8%AF%B7%E6%B1%82%E9%A1%B5%E9%9D%A2%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/04/18/完整的URL请求页面过程/</id>
    <published>2018-04-18T09:15:29.000Z</published>
    <updated>2019-08-13T07:48:25.533Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;当我们在网页浏览器（Web browser）的地址栏中输入URL时，Web页面是如何呈现的？就让我们来聊聊从用户输入到页面加载完成的过程中都发生了什么事情。</p><a id="more"></a><h2 id="请求过程简介"><a href="#请求过程简介" class="headerlink" title="请求过程简介"></a>请求过程简介</h2><p>用户输入URL大概发生了以下一些事：</p><blockquote><p>(1) DNS域名解析到对应的IP地址；<br>  (2) 浏览器向Web服务器发送一个HTTP请求；<br>  (3) 服务器的永久重定向响应;<br>  (4) 浏览器跟踪重定向地址;<br>  (5) 服务器处理请求，并返回一个HTTP响应;<br>  (6) 浏览器显示HTML;</p></blockquote><hr><h2 id="请求过程详解"><a href="#请求过程详解" class="headerlink" title="请求过程详解"></a>请求过程详解</h2><h3 id="DNS查找IP地址"><a href="#DNS查找IP地址" class="headerlink" title="DNS查找IP地址"></a>DNS查找IP地址</h3><p>&emsp;&emsp;DNS是<strong>域名系统</strong>（<em>Domain Name System</em>）的缩写，是因特网的一项核心服务，是和HTTP协议位于应用层的协议，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p><blockquote><p><strong>(一) DNS 查找过程</strong></p><ol><li>浏览器缓存 – 浏览器会缓存DNS记录一段时间，但是操作系统并没有告诉浏览器储存DNS记录的时间，这样不同浏览器会储存个自固定的一个时间（2分钟到30分钟不等）。</li><li>系统缓存 – 如果在浏览器缓存里没有找到需要的记录，浏览器会做一个系统调用（windows里是gethostbyname），这样便可获得系统缓存中的记录。</li><li>路由器缓存 – 接着，前面的查询请求发向路由器，它一般会有自己的DNS缓存。</li><li>ISP DNS缓存 – 接下来要check的就是ISP缓存DNS的服务器。在这一般都能找到相应的缓存记录。</li><li>递归搜索 – 你的ISP的DNS服务器从跟域名服务器开始进行递归搜索，从.com顶级域名服务器到example的域名服务器。一般DNS服务器的缓存中会有.com域名服务器中的域名，所以到顶级服务器的匹配过程不是那么必要了。</li></ol><p><strong>(二) DNS进行域名解析的过程</strong></p><ol><li>客户端发出 DNS 请求翻译 IP 地址或主机名；</li><li>DNS 服务器在收到客户端的请求后，检查 DNS 服务器的缓存，若查到请求的地址或名字，即向客户端发出应答信息；</li><li>若没有查到，则在数据库中查找，若查到请求的地址或名字，即向客户端发出应答信息；</li><li>若没有查到，则将请求发给根域 DNS 服务器，并依序从根域查找顶级域，由顶级查找二级域，二级域查找三级，直至找到要解析的地址或名字。然后，向客户端所在网络的 DNS 服务器发出应答信息，DNS 服务器收到应答后，先在缓存中存储，然后，将解析结果发给客户端。</li><li>若没有找到，则返回错误信息。</li></ol></blockquote><h3 id="HTTP请求"><a href="#HTTP请求" class="headerlink" title="HTTP请求"></a>HTTP请求</h3><blockquote><h4 id="一-三次握手建立TCP连接"><a href="#一-三次握手建立TCP连接" class="headerlink" title="(一) 三次握手建立TCP连接"></a>(一) 三次握手建立TCP连接</h4><p>  &emsp;&emsp;在 http 工作开始之前，浏览器首先要通过网络与服务器建立连接，该连接是通过 TCP 来完成的。该协议与 IP 协议共同构建 Internet ，即著名的 TCP/IP 协议族，因此 Internet 又被称作是 TCP/IP 网络。<strong>http 是比 TCP 更高层次的应用层协议</strong>。根据规则，只有低层协议建立之后才能进行更高次层协议的连接。因此，首先要建立 TCP 连接，一般 TCP 连接的端口号是 80 。在 TCP/IP 协议中，TCP 协议提供可靠的连接服务，采用三次握手建立一个连接：<br>    &emsp;&emsp;1. 第一次握手：建立连接时，客户端发送 SYN 包（syn=j）到服务器，并进入 SYN_SENT 状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）<br>    &emsp;&emsp;2. 第二次握手：服务器收到 SYN 包，必须确认客户的 SYN（ack=j+1），同时自己也发送一个 SYN 包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；<br>    &emsp;&emsp;3. 第三次握手：客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK(ack=k+1），此包发送完毕，客户端和服务器进入 ESTABLISHED（TCP连接成功）状态，完成三次握手。</p></blockquote><blockquote><h4 id="二-完成三次握手，客户端与服务器开始传送数据。"><a href="#二-完成三次握手，客户端与服务器开始传送数据。" class="headerlink" title="(二) 完成三次握手，客户端与服务器开始传送数据。"></a>(二) 完成三次握手，客户端与服务器开始传送数据。</h4><p>  &emsp;&emsp;一旦建立了 TCP 连接，浏览器就会向服务器发送 http 请求命令。浏览器发送其请求命令之后，还要以头信息的形式向服务器发送一些别的信息。此后，浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。</p></blockquote><blockquote><h4 id="三-四次挥手终止连接"><a href="#三-四次挥手终止连接" class="headerlink" title="(三) 四次挥手终止连接"></a>(三) 四次挥手终止连接</h4><p>  &emsp;&emsp;由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。原则是当一方完成它的数据发送任务后，就能发送一个 FIN 来终止这个方向的连接。收到一个 FIN 只意味着这一方向上没有数据流动。一个 TCP 连接在收到一个 FIN 后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。<br>    &emsp;&emsp;1. 第一次挥手：TCP 客户端发送一个 FIN，用来关闭客户端到服务器的数据传送（客户端向服务器发送一个断开连接的请求）;<br>    &emsp;&emsp;2. 第二次挥手：服务器收到这个 FIN，它发回一个 ACK（确认收到请求的信号），确认序号为收到的序号加 1 。和 SYN 一样，一个 FIN 将占用一个序号 (服务器接收到请求之后，发送确认接受到请求的信号);<br>    &emsp;&emsp;3. 第三次挥手：服务器关闭客户端的连接，发送一个 FIN 给客户端 (服务器向客户端发送断开的通知);<br>    &emsp;&emsp;4. 第四次挥手：客户端发回 ACK 报文确认，并将确认序号设置为收到序号加 1  (客户端接收到断开的通知后断开连接，并反馈一个确认信号，服务器接收到确认信号断开连接)。</p></blockquote><h3 id="服务器的永久重定向响应"><a href="#服务器的永久重定向响应" class="headerlink" title="服务器的永久重定向响应"></a>服务器的永久重定向响应</h3><p>&emsp;&emsp;服务器会给浏览器返回一个301永久重定向响应服务器给浏览器响应一个 301 永久重定向响应，这样浏览器就会访问<a href="http://www.facebook.com/" target="_blank" rel="noopener">http://www.facebook.com/</a> 而非 <a href="http://facebook.com/" target="_blank" rel="noopener">http://facebook.com/</a> 。<br>&emsp;&emsp;为什么服务器一定要重定向而不是直接发会用户想看的网页内容呢？其中一个原因跟搜索引擎排名有关。你看，如果一个页面有两个地址，就像 <a href="http://www.igoro.com/" target="_blank" rel="noopener">http://www.igoro.com/</a> 和 <a href="http://igoro.com/" target="_blank" rel="noopener">http://igoro.com/</a> ，搜索引擎会认为它们是两个网站，结果造成每一个的搜索链接都减少从而降低排名。而搜索引擎知道 301 永久重定向是什么意思，这样就会把访问带 www 的和不带 www 的地址归到同一个网站排名下。还有一个原因是用不同的地址会造成缓存友好性变差。当一个页面有好几个名字时，它可能会在缓存里出现好几次。</p><h3 id="浏览器跟踪重定向地址"><a href="#浏览器跟踪重定向地址" class="headerlink" title="浏览器跟踪重定向地址"></a>浏览器跟踪重定向地址</h3><p>&emsp;&emsp;浏览器通过 301 知道 <a href="http://www.facebook.com" target="_blank" rel="noopener">http://www.facebook.com</a> 才是要访问的正确地址，所以它会发送另一个获取请求。</p><h3 id="服务器处理请求，并返回一个HTTP响应"><a href="#服务器处理请求，并返回一个HTTP响应" class="headerlink" title="服务器处理请求，并返回一个HTTP响应"></a>服务器处理请求，并返回一个HTTP响应</h3><p>&emsp;&emsp;服务器接收到获取请求并处理，然后返回一个HTTP响应</p><h3 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h3><p>&emsp;&emsp;现代浏览器渲染页面的过程是这样的：<strong>解析 html 以构建 DOM 树 –&gt; 构建渲染树 –&gt; 布局渲染树 –&gt; 绘制渲染树</strong><br>DOM 树是由 html 文件中的标签排列组成。</p><p>&emsp;&emsp;渲染树是在 DOM 树中加入 css 或 html 中的 style 样式而形成。渲染树只包含需要显示在页面中的 DOM 元素，像 &lt;head&gt;元素或 display 属性值为 none 的元素都不在渲染树中。在浏览器还没接收到完整的 html 文件时，它就开始渲染页面了。</p><p>&emsp;&emsp;在遇到外部链入的脚本标签、样式标签、图片时，会再次发送 http 请求重复上述的步骤。在收到 css 文件后，会对已经渲染的页面重新渲染，加入它们应有的样式。图片文件加载完，立刻显示在相应位置。在这一过程中可能会触发页面的重绘或重排。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&amp;emsp;&amp;emsp;当我们在网页浏览器（Web browser）的地址栏中输入URL时，Web页面是如何呈现的？就让我们来聊聊从用户输入到页面加载完成的过程中都发生了什么事情。&lt;/p&gt;
    
    </summary>
    
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>递归算法</title>
    <link href="http://yoursite.com/2018/04/11/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2018/04/11/递归算法/</id>
    <published>2018-04-11T13:21:29.000Z</published>
    <updated>2019-08-13T08:23:02.587Z</updated>
    
    <content type="html"><![CDATA[<p>大家小时候都听过的：</p><p>从前有座山，山里有座庙，庙里有个老和尚在和小和尚讲故事，故事讲的是</p><a id="more"></a><p><font style="padding-left:30px">从前有座山，山里有座庙，庙里有个老和尚在和小和尚讲故事，故事讲的是</font></p><p><font style="padding-left:60px">从前有座山，山里有座庙，庙里有个老和尚在和小和尚讲故事，故事讲的是</font></p><p><font style="padding-left:90px">……</font></p><p><font style="padding-left:60px">今天的斋饭很好吃.</font></p><br><h3 id="递归的定义"><a href="#递归的定义" class="headerlink" title="递归的定义"></a>递归的定义</h3><hr><h4 id="Wikipedia的定义"><a href="#Wikipedia的定义" class="headerlink" title="Wikipedia的定义"></a>Wikipedia的定义</h4><blockquote><p>Recursion occurs when a thing is defined in terms of itself or of its type. </p></blockquote><h4 id="正式定义"><a href="#正式定义" class="headerlink" title="正式定义"></a>正式定义</h4><blockquote><p>在数学和计算机科学中，递归指由一种（或多种）简单的基本情况定义的一类对象或方法，并规定其他所有情况都能被还原为其基本情况。</p></blockquote><h4 id="对递归的理解"><a href="#对递归的理解" class="headerlink" title="对递归的理解"></a>对递归的理解</h4><p>&emsp;<strong>简单来说，递归就是程序不断的调用自身，递归方法就是方法直接的或者间接的调用自身的方法。</strong><br>&emsp;首先引用一下<a href="https://www.zhihu.com/question/20507130/answer/15551917" target="_blank" rel="noopener">知乎大佬</a>对递归形象生动的理解:</p><p>  &emsp;&emsp;<strong>递归：你打开面前这扇门，看到屋里面还有一扇门（这门可能跟前面打开的门一样大小（静），也可能门小了些（动）），你走过去，发现手中的钥匙还可以打开它，你推开门，发现里面还有一扇门，你继续打开，…， 若干次之后，你打开面前一扇门，发现只有一间屋子，没有门了。 你开始原路返回，每走回一间屋子，你数一次，走到入口的时候，你可以回答出你到底用这钥匙开了几扇门。</strong></p><h4 id="递归的设计和特点"><a href="#递归的设计和特点" class="headerlink" title="递归的设计和特点"></a>递归的设计和特点</h4><blockquote><p>&emsp;&emsp;递归就是对问题进行分解，将大问题转换为小问题并用相同的方法进行求解。对于一个调用，它可以导致更多的调用，继续一层一层的调用下去，当问题分解到不能再分解的时候，就需要一个终止条件返回结果给调用者，调用者计算结果并将结果返回给调用这个调用者的调用者，如此返回下去直到结果传给最开始的那个调用者为止。<br><br><strong>特点：</strong></p><ul><li>反复执行的过程（调用自身）</li><li>结束反复执行过程的条件（跳出方法的条件）</li></ul></blockquote><h4 id="递归的优缺点"><a href="#递归的优缺点" class="headerlink" title="递归的优缺点"></a>递归的优缺点</h4><blockquote><p><strong>优点：</strong></p><ul><li>代码简洁</li></ul><p><strong>缺点：</strong></p><ul><li>时间耗较大，效率可能会低。递归有很多计算可能是重复的，有时候计算会随着n成指数增长，斐波那契数列就是一个例子。</li><li>空间消耗大，可能会导致调用栈溢出。每一次函数调用都需要在内存栈中分配空间，但是每个进程的栈的容量是有限的，当调用的层次太多时，就会超出栈的容量，从而导致栈溢出。</li></ul></blockquote><h3 id="递归常见的算法及应用"><a href="#递归常见的算法及应用" class="headerlink" title="递归常见的算法及应用"></a>递归常见的算法及应用</h3><ul><li>递归求n的阶乘</li><li>递归求斐波那契数列</li></ul><h4 id="递归求n的阶乘"><a href="#递归求n的阶乘" class="headerlink" title="递归求n的阶乘"></a>递归求n的阶乘</h4><p>  &emsp;&emsp;<strong>阶乘</strong>：n的阶乘就是所有比n小的正整数的积，定义 <strong>0的阶乘为1</strong>，n的阶乘为 n!<br>  &emsp;&emsp;要想解决这个问题，我们脑子里先回忆一下递归的特点，然后设计出递归的定义和终止条件。</p><blockquote><p>程序返回的结果肯定是当前n的阶乘的值<br>  <strong>敲敲黑板</strong><br>  <strong>[定义]</strong>：假设我们求的是6的阶乘 [6!]，那么我们就必须知道5的阶乘 [5!]，得出 [ 6！= 5！* 6 ]，接下来以此类推。<br>  <br><br>  <strong>再次敲敲黑板</strong><br>  <strong>[终止条件]</strong>：当我们类推到1的时候，我们都知道1的阶乘就等于1 [ 1!=1 ]，所以此时不需要继续类推下去了，直接返回1就好了。<br>  <br><br><strong>划重点</strong><br>  <strong>[整体思路]</strong>：用函数f()代表阶乘 [n!] : f(n) = f(n-1)*n;<br>  当n不为1时，函数继续调用自身，并且返回前一个数的阶乘的值；当n为1时，返回1的阶乘，也就是 [return 1].<br>  当然你也可以选择返回2的阶乘 [2!=2]或者3的阶乘 [3!=6].</p></blockquote><blockquote><p><strong>代码实现：</strong><br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>( n &lt;= <span class="number">1</span>)&#123;     <span class="comment">//这里也包括了 当n为0的时候 返回1 [0!=1];</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> f(n<span class="number">-1</span>) * n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h4 id="递归求斐波那契数列"><a href="#递归求斐波那契数列" class="headerlink" title="递归求斐波那契数列"></a>递归求斐波那契数列</h4><p>&emsp;&emsp;<strong>斐波那契数列：</strong>它指的是这样一个数列 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233，377，610，987，1597，2584，4181，6765，10946，17711，28657，46368……  这个数列从第三项开始，每一项都等于前两项之和。<br>&emsp;&emsp;同样的，我们需要设计这个问题的递归程序的反复执行过程和跳出执行过程的条件：</p><blockquote><p><strong>[思路]</strong>: 首先，这个递归程序是需要返回斐波那契数列中的第n个数的值<br>&emsp;&emsp;当求[n=6]时，我们需要知道 [n=5] 和 [n=4] 的和，<br>&emsp;&emsp;当[n=5]时，我们要知道 [n=4] 和 [n=3] 的和，<br>&emsp;&emsp;当[n=4]时，我们要知道 [n=3] 和 [n=2] 的和，<br>&emsp;&emsp;类推下去…<br>&emsp;&emsp;当[n=1]或者[n=2]，我们是知道这两项的值的，所以直接返回1.<br><br><br><strong>敲黑板</strong><br><strong>[递归程序]</strong>：fibonacci(n) = fibonacci(n-1) + fibonacci(n-2)<br>&emsp;&emsp;当 n==1 或者 n==2 时，程序直接返回1.<br>&emsp;&emsp;当 n!=1 且 n!=2 时，程序返回 fibonacci(n-1) + fibonacci(n-2).</p></blockquote><blockquote><p><strong>代码实现：</strong><br>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacci</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>( n == <span class="number">1</span> || n == <span class="number">2</span>)&#123;     <span class="comment">//当 n==1 或者 n==2 时，程序直接返回1.;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>);   <span class="comment">//当 n!=1 且 n!=2 时，程序返回 fibonacci(n-1) + fibonacci(n-2).</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大家小时候都听过的：&lt;/p&gt;
&lt;p&gt;从前有座山，山里有座庙，庙里有个老和尚在和小和尚讲故事，故事讲的是&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
</feed>
